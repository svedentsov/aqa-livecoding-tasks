package com.svedentsov.aqa.tasks.algorithms;

/**
 * Решение задачи №36: Найти наибольший общий делитель (НОД / GCD).
 * Описание: Написать функцию для нахождения НОД двух чисел.
 * (Проверяет: алгоритм Евклида, циклы/рекурсия)
 * Задание: Напишите метод `int gcd(int a, int b)`, который вычисляет
 * наибольший общий делитель двух целых чисел `a` и `b`.
 * Пример: `gcd(48, 18)` -> `6`. `gcd(10, 5)` -> `5`. `gcd(7, 13)` -> `1`.
 * `gcd(0, 5)` -> `5`. `gcd(0, 0)` -> `0`.
 */
public class GCD {

    /**
     * Вычисляет наибольший общий делитель (НОД) двух целых чисел
     * с использованием рекурсивной версии алгоритма Евклида.
     * НОД(a, b) = НОД(b, a % b), НОД(a, 0) = |a|.
     * Работает корректно для любых целых чисел. НОД(0, 0) = 0.
     *
     * @param a Первое целое число.
     * @param b Второе целое число.
     * @return Наибольший общий делитель чисел |a| и |b|.
     */
    public int gcdRecursive(int a, int b) {
        // Используем абсолютные значения
        a = Math.abs(a);
        b = Math.abs(b);

        // Базовый случай рекурсии
        if (b == 0) {
            return a; // Если a тоже 0, вернет 0, что принято для НОД(0,0)
        }
        // Рекурсивный вызов
        return gcdRecursive(b, a % b);
    }

    /**
     * Вычисляет наибольший общий делитель (НОД) двух целых чисел
     * с использованием итеративной версии алгоритма Евклида.
     *
     * @param a Первое целое число.
     * @param b Второе целое число.
     * @return Наибольший общий делитель чисел |a| и |b|.
     */
    public int gcdIterative(int a, int b) {
        a = Math.abs(a);
        b = Math.abs(b);

        // Итеративный алгоритм Евклида
        while (b != 0) {
            int temp = b; // Сохраняем b, т.к. оно понадобится как новое 'a'
            b = a % b;    // Новое 'b' - это остаток
            a = temp;     // Новое 'a' - это старое 'b'
        }
        // Когда b становится 0, значение 'a' содержит НОД
        return a;
    }
}

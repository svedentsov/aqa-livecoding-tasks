package com.svedentsov.aqa.tasks.algorithms;

/**
 * Решение задачи №13: Проверка на простое число.
 * <p>
 * Описание: Написать функцию, которая определяет, является ли данное число простым.
 * (Проверяет: циклы, условия, оптимизация)
 * <p>
 * Задание: Напишите метод `boolean isPrime(int number)`, который возвращает `true`,
 * если `number` является простым, и `false` иначе. Простое число - натуральное > 1,
 * делящееся только на 1 и на себя.
 * <p>
 * Пример: `isPrime(7)` -> `true`, `isPrime(10)` -> `false`, `isPrime(2)` -> `true`.
 */
public class PrimeNumberCheck {

    /**
     * Проверяет, является ли заданное целое число простым.
     * Простое число - это натуральное число больше 1, которое не имеет других
     * делителей, кроме 1 и самого себя.
     * Используется оптимизированный метод проверки делителей:
     * 1. Отбрасываются числа <= 1.
     * 2. Отбрасываются четные числа > 2.
     * 3. Отбрасываются числа > 3, кратные 3.
     * 4. Проверяются делители вида 6k ± 1 до квадратного корня из числа.
     *
     * @param number Целое число для проверки.
     * @return {@code true}, если число простое, {@code false} в противном случае.
     */
    public boolean isPrime(int number) {
        // Шаг 1: Числа <= 1 не являются простыми по определению
        if (number <= 1) {
            return false;
        }
        // Шаг 2: Числа 2 и 3 - базовые простые случаи
        if (number == 2 || number == 3) {
            return true;
        }
        // Шаг 3: Оптимизация - убираем все четные > 2 и кратные 3 (кроме 3)
        if (number % 2 == 0 || number % 3 == 0) {
            return false;
        }

        // Шаг 4: Проверяем делители вида 6k ± 1 до sqrt(number)
        // Все простые числа > 3 можно представить в виде 6k ± 1.
        // Нам нужно проверять делимость только на простые числа. Проверяя
        // i и i+2 для i=5, 11, 17... (шаг 6), мы покрываем все простые делители.
        // Используем i * i <= number вместо i <= Math.sqrt(number) для эффективности
        // и избежания работы с double. Применяем long для i*i, чтобы избежать
        // переполнения при проверке квадрата i для больших number (близких к Integer.MAX_VALUE).
        for (long i = 5; i * i <= number; i += 6) {
            // Если number делится на i (формат 6k-1) или на i+2 (формат 6k+1)
            if (number % i == 0 || number % (i + 2) == 0) {
                return false; // Найден делитель - число не простое
            }
        }
        // Если цикл завершился без нахождения делителей, число простое
        return true;
    }
}

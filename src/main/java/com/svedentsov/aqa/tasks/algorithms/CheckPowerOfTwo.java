package com.svedentsov.aqa.tasks.algorithms;

/**
 * Решение задачи №28: Проверить, является ли число степенью двойки.
 * <p>
 * Описание: Написать функцию для такой проверки.
 * (Проверяет: битовые операции/циклы)
 * <p>
 * Задание: Напишите метод `boolean isPowerOfTwo(int n)`, который возвращает `true`,
 * если положительное целое число `n` является степенью двойки (1, 2, 4, 8, 16...),
 * и `false` иначе.
 * <p>
 * Пример: `isPowerOfTwo(1)` -> `true`, `isPowerOfTwo(16)` -> `true`,
 * `isPowerOfTwo(10)` -> `false`, `isPowerOfTwo(0)` -> `false`.
 */
public class CheckPowerOfTwo {

    /**
     * Проверяет, является ли положительное целое число n степенью двойки (1, 2, 4, 8...).
     * Использует эффективный битовый трюк: `(n & (n - 1)) == 0`.
     *
     * @param n Целое число для проверки.
     * @return {@code true}, если n является положительной степенью двойки, {@code false} в противном случае.
     */
    public boolean isPowerOfTwoBitwise(int n) {
        // 1. Степени двойки должны быть положительными (n > 0).
        // 2. Применяем битовый трюк.
        return (n > 0) && ((n & (n - 1)) == 0);
    }

    /**
     * Проверяет, является ли положительное целое число n степенью двойки.
     * Использует итеративное деление на 2.
     *
     * @param n Целое число для проверки.
     * @return {@code true}, если n является положительной степенью двойки, {@code false} в противном случае.
     */
    public boolean isPowerOfTwoIterative(int n) {
        // Шаг 1: Исключаем 0 и отрицательные числа
        if (n <= 0) {
            return false;
        }
        // Шаг 2: Итеративное деление
        int current = n; // Работаем с копией, чтобы не изменять параметр (хотя он и так по значению)
        while (current % 2 == 0) {
            current /= 2;
        }
        // Шаг 3: Проверка результата
        // Если исходное n было степенью двойки, в конце останется 1.
        return current == 1;
    }
}

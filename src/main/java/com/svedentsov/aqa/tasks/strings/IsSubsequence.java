package com.svedentsov.aqa.tasks.strings;

/**
 * Решение задачи №53: Проверка на подпоследовательность.
 * Описание: Проверить, является ли одна строка подпоследовательностью другой
 * (символы идут в том же порядке, но не обязательно подряд).
 * (Проверяет: работа со строками, два указателя)
 * Задание: Напишите метод `boolean isSubsequence(String s, String t)`, который
 * возвращает `true`, если строка `s` является подпоследовательностью строки `t`
 * (т.е. `s` можно получить из `t` удалением некоторых символов без изменения
 * порядка оставшихся), и `false` иначе.
 * Пример: `isSubsequence("ace", "abcde")` -> `true`.
 * `isSubsequence("axc", "ahbgdc")` -> `false`.
 */
public class IsSubsequence {

    /**
     * Проверяет, является ли строка {@code s} подпоследовательностью строки {@code t}.
     * Использует метод двух указателей.
     * Сложность: O(|t|) по времени, O(1) по памяти.
     *
     * @param s Строка, которая проверяется (потенциальная подпоследовательность). Может быть null.
     * @param t Строка, в которой ищется подпоследовательность {@code s}. Может быть null.
     * @return {@code true}, если {@code s} является подпоследовательностью {@code t},
     * {@code false} в противном случае.
     */
    public boolean isSubsequence(String s, String t) {
        // Шаг 1: Обработка null
        if (s == null || t == null) {
            return false;
        }

        int sLen = s.length();
        int tLen = t.length();

        // Шаг 2: Обработка пустой строки s
        if (sLen == 0) {
            return true; // Пустая строка всегда подпоследовательность
        }
        // Если s не пуста, а t пуста, то s не может быть подпоследовательностью t
        // Эта проверка также покрывается sLen > tLen, но для ясности можно оставить.
        if (tLen == 0) { // Подразумевается, что sLen > 0 из предыдущего if
            return false;
        }
        // Если s длиннее t, s не может быть подпоследовательностью t
        if (sLen > tLen) {
            return false;
        }

        // Шаг 3: Инициализация указателей
        int sPointer = 0;
        int tPointer = 0;

        // Шаг 4: Итерация по строкам
        // Продолжаем, пока не дошли до конца одной из строк
        while (sPointer < sLen && tPointer < tLen) {
            // Если символы совпадают, двигаем указатель s
            if (s.charAt(sPointer) == t.charAt(tPointer)) {
                sPointer++;
            }
            // Всегда двигаем указатель t
            tPointer++;
        }

        // Шаг 5: Если sPointer достиг конца s, значит все символы s были найдены
        // в t в нужном порядке.
        return sPointer == sLen;
    }
}

package com.svedentsov.aqa.tasks.strings;

/**
 * Решение задачи №41: Валидация IP-адреса (IPv4).
 * <p>
 * Описание: Написать функцию для проверки строки на соответствие формату IPv4.
 * (Проверяет: работа со строками, `split()`, условия, парсинг чисел)
 * <p>
 * Задание: Напишите метод `boolean isValidIPv4(String ip)`, который проверяет,
 * является ли строка `ip` валидным IPv4 адресом. Валидный адрес состоит из
 * четырех чисел от 0 до 255, разделенных точками. Ведущие нули не допускаются
 * (кроме самого числа 0).
 * <p>
 * Пример: `isValidIPv4("192.168.0.1")` -> `true`.
 * `isValidIPv4("255.255.255.255")` -> `true`.
 * `isValidIPv4("0.0.0.0")` -> `true`.
 * `isValidIPv4("256.1.1.1")` -> `false`.
 * `isValidIPv4("192.168.0.01")` -> `false`.
 * `isValidIPv4("192.168..1")` -> `false`.
 * `isValidIPv4("abc.def.ghi.jkl")` -> `false`.
 */
public class ValidateIpAddress {

    /**
     * Проверяет, является ли строка валидным IPv4 адресом.
     * Валидный IPv4 адрес состоит из четырех чисел (октетов) от 0 до 255,
     * разделенных точками. Ведущие нули не допускаются, кроме самого числа "0".
     * Использует разбор строки и проверку частей.
     *
     * @param ip Строка для проверки. Может быть null.
     * @return {@code true}, если строка является валидным IPv4 адресом, {@code false} в противном случае.
     */
    public boolean isValidIPv4(String ip) {
        // Шаг 1: Проверка на null
        if (ip == null) {
            return false;
        }

        // Шаг 2: Разделение по точкам
        // Используем "\\." т.к. "." - спецсимвол в regex.
        // Лимит -1 гарантирует, что конечные пустые строки не будут отброшены (например, "1.2.3.").
        String[] parts = ip.split("\\.", -1);

        // Шаг 3: Проверка количества частей
        if (parts.length != 4) {
            return false;
        }

        // Шаг 4: Проверка каждой части
        for (String part : parts) {
            // Шаг 4a, 4b: Проверка на пустоту и длину
            if (part.isEmpty() || part.length() > 3) {
                return false;
            }

            // Шаг 4c: Проверка на ведущие нули (кроме единственного нуля "0")
            if (part.length() > 1 && part.charAt(0) == '0') {
                return false;
            }

            // Шаг 4d, 4e: Парсинг и проверка диапазона
            try {
                int num = Integer.parseInt(part);
                // Проверка диапазона [0, 255]
                if (num < 0 || num > 255) {
                    return false;
                }
                // Проверка на нецифровые символы неявно происходит при parseInt
            } catch (NumberFormatException e) {
                // Если parseInt бросил исключение (например, для "abc") -> невалидно
                return false;
            }
        }

        // Шаг 5: Если все проверки пройдены
        return true;
    }
}

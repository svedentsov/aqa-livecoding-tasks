package com.svedentsov.aqa.tasks.graphs_matrices;

/**
 * Решение задачи №90: Игра "Жизнь" Конвея (один шаг).
 * Описание: Рассчитать следующее состояние для одной клетки или небольшой матрицы.
 * (Проверяет: работа с 2D массивами, логика)
 * Задание: Напишите метод `int[][] nextGeneration(int[][] board)`, который
 * принимает 2D массив `board` (0 - мертвая клетка, 1 - живая) и вычисляет
 * следующее состояние поля согласно правилам игры "Жизнь" Конвея. Верните новое поле.
 * Правила:
 * 1. Живая (1) с < 2 живыми соседями -> умирает (0).
 * 2. Живая (1) с 2 или 3 живыми соседями -> выживает (1).
 * 3. Живая (1) с > 3 живыми соседями -> умирает (0).
 * 4. Мертвая (0) с ровно 3 живыми соседями -> оживает (1).
 * Пример: Показать небольшой пример 3x3 поля и его состояние на следующем шаге.
 */
public class GameOfLifeStep {

    /**
     * Вычисляет следующее поколение (состояние) игрового поля для игры "Жизнь" Конвея.
     * Применяет правила к каждой клетке на основе её 8 соседей.
     * Границы поля считаются мертвыми.
     * Возвращает новое поле, не изменяя исходное.
     *
     * @param board Текущее состояние поля (0 - мертвая, 1 - живая).
     * Предполагается, что массив не null и прямоугольный, содержит только 0 или 1.
     * @return Новый 2D массив {@code int[][]}, представляющий состояние поля
     * в следующем поколении. Возвращает пустой массив {@code new int[0][0]},
     * если исходный {@code board} null, пуст, или содержит пустые/null строки.
     */
    public int[][] nextGeneration(int[][] board) {
        // Проверка входных данных
        if (board == null || board.length == 0 || board[0] == null || board[0].length == 0) {
            return new int[0][0]; // Или можно вернуть null/бросить исключение
        }

        int rows = board.length;
        int cols = board[0].length;
        // Новое поле для следующего поколения
        int[][] nextBoard = new int[rows][cols];

        for (int r = 0; r < rows; r++) {
            // Проверка на случай зубчатого массива, если строка короче ожидаемой.
            // Хотя обычно предполагается прямоугольный массив.
            if (board[r] == null || board[r].length != cols) {
                // Можно бросить исключение или вернуть ошибку,
                // но для простоты и совместимости с пустым board[0] вернем пустой.
                // Либо, если доверяем, что board[r].length == cols всегда (из-за board[0].length)
                // System.err.println("Warning: Jagged array detected or null row at index " + r);
                // return new int[0][0]; // Или обработать как ошибку
            }

            for (int c = 0; c < cols; c++) {
                // Подсчет живых соседей
                int liveNeighbors = countLiveNeighbors(board, r, c);
                int currentState = board[r][c];
                int nextState = 0; // По умолчанию клетка мертва

                // Применение правил "Жизни"
                if (currentState == 1) { // Если клетка жива
                    if (liveNeighbors == 2 || liveNeighbors == 3) {
                        nextState = 1; // Выживает
                    } // Иначе умирает (от одиночества <2 или перенаселения >3), nextState остается 0
                } else { // Мертвая клетка
                    if (liveNeighbors == 3) {
                        nextState = 1; // Оживает
                    } // Иначе остается мертвой, nextState остается 0
                }
                nextBoard[r][c] = nextState; // Записываем новое состояние
            }
        }
        return nextBoard;
    }

    /**
     * Вспомогательный метод для подсчета живых соседей клетки (r, c).
     * Учитывает 8 соседей, клетки за границами считаются мертвыми.
     *
     * @param board Игровое поле.
     * @param r     Строка текущей клетки.
     * @param c     Столбец текущей клетки.
     * @return Количество живых соседей (0-8).
     */
    private int countLiveNeighbors(int[][] board, int r, int c) {
        int rows = board.length;
        int cols = board[0].length;
        int liveCount = 0;

        // Перебираем всех 8 соседей, включая диагональные
        for (int i = r - 1; i <= r + 1; i++) {
            for (int j = c - 1; j <= c + 1; j++) {
                if (i == r && j == c) { // Пропускаем саму клетку
                    continue;
                }
                // Проверка границ поля
                if (i >= 0 && i < rows && j >= 0 && j < cols) {
                    // Проверяем, что board[i] не null и имеет достаточную длину
                    // Это для дополнительной защиты от зубчатых массивов, если board[i].length < cols
                    if (board[i] != null && j < board[i].length && board[i][j] == 1) {
                        liveCount++;
                    }
                }
            }
        }
        return liveCount;
    }
}

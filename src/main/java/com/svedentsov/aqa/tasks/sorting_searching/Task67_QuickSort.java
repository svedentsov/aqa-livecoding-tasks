package com.svedentsov.aqa.tasks.sorting_searching;

import java.util.Arrays;
import java.util.Random;

/**
 * Решение задачи №67: Быстрая сортировка (Quick Sort).
 */
public class Task67_QuickSort {

    // Генератор случайных чисел для выбора опорного элемента (pivot)
    private static final Random RAND = new Random();

    /**
     * Сортирует массив целых чисел по возрастанию, используя алгоритм быстрой сортировки (QuickSort).
     * Алгоритм работает по принципу "разделяй и властвуй":
     * 1. Выбор опорного элемента (pivot).
     * 2. Разделение (partitioning): перераспределение элементов массива так, чтобы элементы
     * меньше опорного оказались слева от него, а большие или равные - справа.
     * 3. Рекурсия: рекурсивный вызов quickSort для подмассивов слева и справа от опорного элемента.
     * Сложность:
     * - В среднем: O(n log n) по времени.
     * - В худшем случае (если опорный элемент постоянно выбирается неудачно, например,
     * наименьший/наибольший элемент в уже отсортированном/обратно отсортированном массиве): O(n^2) по времени.
     * Использование случайного выбора опорного элемента значительно снижает вероятность худшего случая.
     * - O(log n) по дополнительной памяти в среднем (из-за глубины стека рекурсии), O(n) в худшем случае.
     * Сортировка выполняется "на месте" (in-place).
     * Не является стабильным алгоритмом сортировки (относительный порядок равных элементов может измениться).
     *
     * @param arr Массив для сортировки. Может быть null. Модифицируется на месте.
     */
    public void quickSort(int[] arr) {
        // Если массив null или содержит 0/1 элемент, он уже отсортирован.
        if (arr == null || arr.length <= 1) {
            return;
        }
        // Запускаем рекурсивную сортировку для всего массива.
        quickSortRecursive(arr, 0, arr.length - 1);
    }

    /**
     * Рекурсивная функция быстрой сортировки для подмассива {@code arr[low..high]}.
     *
     * @param arr  Массив.
     * @param low  Нижняя граница (индекс) подмассива (включительно).
     * @param high Верхняя граница (индекс) подмассива (включительно).
     */
    private void quickSortRecursive(int[] arr, int low, int high) {
        // Базовый случай рекурсии: если подмассив содержит менее 2 элементов (low >= high).
        if (low < high) {
            // 1. Выполняем разделение подмассива arr[low..high] относительно опорного элемента.
            //    Метод partition возвращает индекс, на котором опорный элемент встал после разделения.
            int pivotIndex = partitionRandom(arr, low, high);

            // 2. Рекурсивно сортируем левый подмассив (элементы от low до pivotIndex - 1).
            quickSortRecursive(arr, low, pivotIndex - 1);
            // 3. Рекурсивно сортируем правый подмассив (элементы от pivotIndex + 1 до high).
            quickSortRecursive(arr, pivotIndex + 1, high);
        }
    }

    /**
     * Выполняет разделение (partitioning) подмассива {@code arr[low..high]}
     * относительно случайно выбранного опорного элемента (pivot).
     * Использует вариацию схемы разделения Ломуто.
     * Перемещает все элементы меньше или равные опорному влево от него,
     * а большие - вправо.
     *
     * @param arr  Массив.
     * @param low  Нижняя граница подмассива.
     * @param high Верхняя граница подмассива.
     * @return Индекс, на котором опорный элемент оказался после разделения.
     */
    private int partitionRandom(int[] arr, int low, int high) {
        // 1. Выбираем случайный индекс для опорного элемента в диапазоне [low, high].
        int pivotIndex = low + RAND.nextInt(high - low + 1);
        int pivotValue = arr[pivotIndex];

        // 2. Перемещаем опорный элемент в конец подмассива (на позицию high) для удобства обработки.
        swap(arr, pivotIndex, high);

        // 3. `storeIndex` отслеживает позицию, куда будет помещен следующий элемент,
        //    который меньше или равен опорному. Изначально указывает на начало подмассива.
        int storeIndex = low;

        // 4. Проходим по подмассиву от `low` до `high-1` (не включая опорный элемент в конце).
        for (int i = low; i < high; i++) {
            // Если текущий элемент `arr[i]` меньше или равен опорному значению `pivotValue`
            if (arr[i] <= pivotValue) {
                // Меняем местами `arr[i]` с элементом на позиции `storeIndex`.
                swap(arr, storeIndex, i);
                // Сдвигаем `storeIndex` вправо, чтобы указать на следующую позицию
                // для элементов, меньших или равных опорному.
                storeIndex++;
            }
            // Если arr[i] > pivotValue, ничего не делаем, `i` просто двигается дальше,
            // оставляя больший элемент справа от `storeIndex`.
        }

        // 5. После цикла все элементы от `low` до `storeIndex - 1` включительно
        //    меньше или равны `pivotValue`.
        //    Теперь ставим опорный элемент (который был в `arr[high]`) на его
        //    правильное место - позицию `storeIndex`.
        swap(arr, storeIndex, high);

        // 6. Возвращаем индекс `storeIndex`, на котором теперь стоит опорный элемент.
        return storeIndex;
    }

    /**
     * Вспомогательный метод для обмена двух элементов в массиве по индексам.
     *
     * @param arr Массив.
     * @param i   Индекс первого элемента.
     * @param j   Индекс второго элемента.
     */
    private void swap(int[] arr, int i, int j) {
        // Пропускаем обмен, если индексы одинаковы
        if (i == j) return;
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    /**
     * Точка входа для демонстрации работы метода быстрой сортировки.
     *
     * @param args Аргументы командной строки (не используются).
     */
    public static void main(String[] args) {
        Task67_QuickSort sol = new Task67_QuickSort();

        int[][] testArrays = {
                {5, 1, 4, 2, 8, 5, 0, -3, 99},
                {1},
                {3, 1},
                {},
                {9, 8, 7, 6, 5, 4, 3, 2, 1}, // Обратно отсортированный
                {1, 2, 3, 4, 5, 6, 7, 8, 9}, // Уже отсортированный
                {2, 3, 1, 5, 4, 7, 6, 9, 8} // Случайный порядок
        };

        for (int[] arr : testArrays) {
            int[] arrCopy = (arr == null) ? null : arr.clone(); // Копируем для вывода оригинала
            System.out.println("\nOriginal: " + Arrays.toString(arrCopy));
            sol.quickSort(arr); // Сортируем массив на месте
            System.out.println("Sorted:   " + Arrays.toString(arr));
        }
    }
}

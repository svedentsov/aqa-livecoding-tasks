package com.svedentsov.aqa.tasks.sorting_searching;

/**
 * Решение задачи №16: Сортировка массива методом пузырька (Bubble Sort).
 * <p>
 * Описание: Реализовать простой алгоритм сортировки (пузырьком, выбором).
 * (Проверяет: основы алгоритмов)
 * <p>
 * Задание: Реализуйте метод `void bubbleSort(int[] arr)`, который сортирует
 * массив `arr` по возрастанию, используя алгоритм пузырьковой сортировки.
 * <p>
 * Пример: Исходный массив `[5, 1, 4, 2, 8]` после вызова `bubbleSort`
 * должен стать `[1, 2, 4, 5, 8]`.
 */
public class BubbleSort {

    /**
     * Сортирует массив целых чисел по возрастанию с использованием алгоритма пузырьковой сортировки.
     * Алгоритм многократно проходит по массиву, сравнивая и меняя местами соседние
     * элементы, если они находятся в неправильном порядке (arr[j] > arr[j+1]).
     * В результате каждого прохода наибольший элемент текущего неотсортированного
     * подмассива "всплывает" на свою окончательную позицию.
     * Реализация включает оптимизацию: если во время прохода не произошло ни одного
     * обмена, массив считается отсортированным, и процесс завершается досрочно.
     * <p>
     * Сложность:
     * - Время: O(n^2) в худшем (обратно отсортированный массив) и среднем случаях.
     * O(n) в лучшем случае (уже отсортированный массив, благодаря оптимизации).
     * - Память: O(1) (сортировка на месте, используется только временная переменная для обмена).
     * <p>
     * Неэффективен для больших наборов данных по сравнению с O(n log n) алгоритмами
     * (слияние, быстрая сортировка, пирамидальная).
     *
     * @param arr Массив для сортировки. Сортируется на месте (in-place).
     *            Если массив null или содержит менее 2 элементов, метод ничего не делает.
     */
    public void bubbleSort(int[] arr) {
        // Если массив null или содержит 0/1 элемент, он уже считается отсортированным
        // или не требует сортировки. Метод просто завершается.
        if (arr == null || arr.length < 2) {
            return;
        }

        int n = arr.length;
        boolean swapped; // Флаг для оптимизации

        // Внешний цикл: n-1 проходов в худшем случае
        for (int i = 0; i < n - 1; i++) {
            swapped = false; // Сбрасываем флаг

            // Внутренний цикл: сравнение и обмен соседних элементов
            // Граница n - 1 - i: после i-го прохода последние i элементов отсортированы
            for (int j = 0; j < n - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    // Обмен значениями
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true; // Устанавливаем флаг, так как произошел обмен
                }
            }

            // Оптимизация: если за проход не было обменов, массив отсортирован
            if (!swapped) {
                break;
            }
        }
    }
}

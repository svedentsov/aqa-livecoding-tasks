package com.svedentsov.aqa.tasks.sorting_searching;

/**
 * Решение задачи №66: Сортировка слиянием (Merge Sort).
 * Описание: Реализовать алгоритм.
 * (Проверяет: рекурсия, алгоритмы сортировки)
 * Задание: Реализуйте метод `void mergeSort(int[] arr)`, который сортирует
 * массив `arr` по возрастанию, используя рекурсивный алгоритм сортировки слиянием.
 * Пример: Исходный `[5, 1, 4, 2, 8]` после `mergeSort` станет `[1, 2, 4, 5, 8]`.
 */
public class MergeSort {

    /**
     * Сортирует массив целых чисел по возрастанию, используя алгоритм сортировки слиянием.
     * Модифицирует исходный массив {@code arr} на месте.
     * Сложность: O(n log n) по времени (всегда), O(n) по дополнительной памяти для temp массива.
     *
     * @param arr Массив для сортировки. Может быть null.
     */
    public void mergeSort(int[] arr) {
        // Проверка на null и тривиальные случаи (0 или 1 элемент уже отсортированы)
        if (arr == null || arr.length <= 1) {
            return;
        }
        // Создаем временный буферный массив один раз
        int[] temp = new int[arr.length];
        // Запускаем рекурсивную сортировку
        mergeSortRecursive(arr, temp, 0, arr.length - 1);
    }

    /**
     * Рекурсивная функция сортировки слиянием для подмассива arr[left..right].
     *
     * @param arr   Массив (или подмассив), который сортируется.
     * @param temp  Временный массив того же размера, что и arr, для операции слияния.
     * @param left  Левая граница (индекс) текущего подмассива (включительно).
     * @param right Правая граница (индекс) текущего подмассива (включительно).
     */
    private void mergeSortRecursive(int[] arr, int[] temp, int left, int right) {
        // Базовый случай рекурсии: если подмассив содержит 0 или 1 элемент
        if (left >= right) {
            return;
        }

        // Находим середину
        int mid = left + (right - left) / 2;

        // Рекурсивно сортируем левую и правую половины
        mergeSortRecursive(arr, temp, left, mid);
        mergeSortRecursive(arr, temp, mid + 1, right);

        // Оптимизация: если массив уже отсортирован на этом участке, слияние не нужно.
        // arr[mid] - последний элемент левой отсортированной части
        // arr[mid + 1] - первый элемент правой отсортированной части
        if (arr[mid] <= arr[mid + 1]) {
            return;
        }

        // Сливаем две отсортированные половины
        merge(arr, temp, left, mid, right);
    }

    /**
     * Сливает два соседних отсортированных подмассива {@code arr[left..mid]} и {@code arr[mid+1..right]}
     * в один отсортированный подмассив {@code arr[left..right]}, используя временный массив {@code temp}.
     *
     * @param arr   Основной массив, содержащий подмассивы для слияния.
     * @param temp  Временный массив для копирования данных перед слиянием.
     * @param left  Начальный индекс первого подмассива (и всего сливаемого диапазона).
     * @param mid   Конечный индекс первого подмассива.
     * @param right Конечный индекс второго подмассива (и всего сливаемого диапазона).
     */
    private void merge(int[] arr, int[] temp, int left, int mid, int right) {
        // 1. Копируем весь диапазон [left..right] из arr в temp
        // Длина копируемого участка: (right - left + 1)
        if (right - left + 1 >= 0) { // Проверка на случай, если left > right (хотя рекурсия должна это предотвращать)
            System.arraycopy(arr, left, temp, left, right - left + 1);
        }

        // 2. Инициализируем указатели для слияния
        int i = left;     // Указатель для левой половины в temp (temp[left..mid])
        int j = mid + 1;  // Указатель для правой половины в temp (temp[mid+1..right])
        int k = left;     // Указатель для записи результата обратно в arr (arr[left..right])

        // 3. Слияние: пока есть элементы в обеих половинах
        while (i <= mid && j <= right) {
            // Сравниваем элементы из левой и правой половин во временном массиве
            if (temp[i] <= temp[j]) {
                arr[k++] = temp[i++]; // Берем из левой
            } else {
                arr[k++] = temp[j++]; // Берем из правой
            }
        }

        // 4. Копируем оставшиеся элементы из левой половины (если есть)
        while (i <= mid) {
            arr[k++] = temp[i++];
        }

        // 5. Копируем оставшиеся элементы из правой половины (если есть)
        // Эта часть необходима, т.к. если левая половина закончилась первой,
        // оставшиеся элементы правой половины из temp нужно скопировать в arr.
        while (j <= right) {
            arr[k++] = temp[j++];
        }
    }
}

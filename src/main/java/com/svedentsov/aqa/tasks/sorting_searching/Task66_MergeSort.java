package com.svedentsov.aqa.tasks.sorting_searching;

import java.util.Arrays;

/**
 * Решение задачи №66: Сортировка слиянием (Merge Sort).
 */
public class Task66_MergeSort {

    /**
     * Сортирует массив целых чисел по возрастанию, используя алгоритм сортировки слиянием.
     * Алгоритм работает по принципу "разделяй и властвуй":
     * 1. Разделение: Рекурсивно делит массив на две половины до тех пор, пока подмассивы
     * не будут содержать по одному элементу (или будут пустыми). Одноэлементные массивы считаются отсортированными.
     * 2. Слияние (Merge): Сливает две отсортированные половины в один общий отсортированный подмассив.
     * Этот шаг требует дополнительной памяти.
     * Сложность O(n log n) по времени в худшем, среднем и лучшем случаях.
     * Сложность O(n) по дополнительной памяти из-за временных массивов, используемых при слиянии.
     * Является стабильным алгоритмом сортировки (не меняет относительный порядок равных элементов).
     *
     * @param arr Массив для сортировки. Может быть null. Модифицируется на месте.
     */
    public void mergeSort(int[] arr) {
        // Если массив null или содержит 0/1 элемент, он уже отсортирован.
        if (arr == null || arr.length <= 1) {
            return;
        }
        // Запускаем рекурсивную сортировку для всего массива (индексы от 0 до length-1).
        mergeSortRecursive(arr, 0, arr.length - 1);
    }

    /**
     * Рекурсивная функция сортировки слиянием для подмассива arr[left..right].
     *
     * @param arr   Массив (или подмассив), который сортируется.
     * @param left  Левая граница (индекс) текущего подмассива (включительно).
     * @param right Правая граница (индекс) текущего подмассива (включительно).
     */
    private void mergeSortRecursive(int[] arr, int left, int right) {
        // Базовый случай рекурсии: если подмассив содержит 0 или 1 элемент (left >= right).
        if (left < right) {
            // Находим середину подмассива для разделения.
            // Используем (right - left) / 2 для предотвращения переполнения при сложении.
            int mid = left + (right - left) / 2;

            // Рекурсивно сортируем левую половину (от left до mid).
            mergeSortRecursive(arr, left, mid);
            // Рекурсивно сортируем правую половину (от mid+1 до right).
            mergeSortRecursive(arr, mid + 1, right);

            // Сливаем две уже отсортированные половины в один отсортированный подмассив arr[left..right].
            merge(arr, left, mid, right);
        }
    }

    /**
     * Сливает два соседних отсортированных подмассива {@code arr[left..mid]} и {@code arr[mid+1..right]}
     * в один отсортированный подмассив {@code arr[left..right]}.
     *
     * @param arr   Основной массив, содержащий подмассивы для слияния.
     * @param left  Начальный индекс первого подмассива (и всего сливаемого диапазона).
     * @param mid   Конечный индекс первого подмассива.
     * @param right Конечный индекс второго подмассива (и всего сливаемого диапазона).
     */
    private void merge(int[] arr, int left, int mid, int right) {
        // 1. Вычисляем размеры двух временных подмассивов.
        int n1 = mid - left + 1; // Размер левого подмассива
        int n2 = right - mid;    // Размер правого подмассива

        // 2. Создаем временные массивы для хранения левой и правой половин.
        int[] leftArray = new int[n1];
        int[] rightArray = new int[n2];

        // 3. Копируем данные из основного массива `arr` во временные массивы.
        // Копируем из arr[left...mid] в leftArray[0...n1-1]
        System.arraycopy(arr, left, leftArray, 0, n1);
        // Копируем из arr[mid+1...right] в rightArray[0...n2-1]
        System.arraycopy(arr, mid + 1, rightArray, 0, n2);

        // 4. Слияние временных массивов обратно в основной массив `arr`.
        int i = 0; // Индекс для итерации по leftArray
        int j = 0; // Индекс для итерации по rightArray
        int k = left; // Индекс для записи в основной массив `arr`, начиная с `left`

        // Пока есть элементы для сравнения в обоих временных массивах
        while (i < n1 && j < n2) {
            // Сравниваем элементы из левого и правого массивов
            if (leftArray[i] <= rightArray[j]) {
                // Если элемент из левого массива меньше или равен, копируем его
                arr[k] = leftArray[i];
                i++; // Двигаем указатель левого массива
            } else {
                // Иначе копируем элемент из правого массива
                arr[k] = rightArray[j];
                j++; // Двигаем указатель правого массива
            }
            k++; // Двигаем указатель основного массива
        }

        // 5. Копируем оставшиеся элементы из левого подмассива (если они есть).
        // Это произойдет, если все элементы правого массива (rightArray) уже скопированы.
        while (i < n1) {
            arr[k] = leftArray[i];
            i++;
            k++;
        }

        // 6. Копируем оставшиеся элементы из правого подмассива (если они есть).
        // Это произойдет, если все элементы левого массива (leftArray) уже скопированы.
        while (j < n2) {
            arr[k] = rightArray[j];
            j++;
            k++;
        }
    }

    /**
     * Точка входа для демонстрации работы метода сортировки слиянием.
     *
     * @param args Аргументы командной строки (не используются).
     */
    public static void main(String[] args) {
        Task66_MergeSort sol = new Task66_MergeSort();
        int[][] testArrays = {
                {5, 1, 4, 2, 8, 5, 0, -3, 99},
                {1},
                {3, 1},
                {},
                {9, 8, 7, 6, 5},
                {2, 3, 1, 5, 4}
        };

        for (int[] arr : testArrays) {
            System.out.println("\nOriginal: " + Arrays.toString(arr));
            sol.mergeSort(arr); // Сортируем массив на месте
            System.out.println("Sorted:   " + Arrays.toString(arr));
        }
        System.out.println("\nOriginal: null");
        sol.mergeSort(null);
        System.out.println("Sorted:   null");

    }
}
